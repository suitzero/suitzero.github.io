<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pinhole Camera Shader Simulation</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #ui-layer {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: monospace;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            pointer-events: none;
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        #coords {
            color: #8af;
            white-space: pre-line;
            font-weight: bold;
            border-top: 1px solid #555;
            padding-top: 10px;
        }
    </style>
</head>
<body>
    <div id="ui-layer">
        <div>
            <b>Pinhole Camera Simulation</b><br/>
            <b>WASD</b> + <b>Q/E</b> to Move<br/>
            <b>Left Click & Drag</b> to Look<br/>
            <b>Right Click</b> to animate inside main box.<br/>
        </div>
        <div id="coords">Initializing...</div>
    </div>
    <canvas id="glcanvas"></canvas>

    <script>
        // --- CONFIGURATION: SET INITIAL POSITION HERE ---
        const INITIAL_CAM_POS = { x: -7.35, y: 0.0, z: -0.13 };
        const INITIAL_YAW = 1.26;
        const INITIAL_PITCH = -0.05;
        // ------------------------------------------------

        const canvas = document.getElementById('glcanvas');
        const gl = canvas.getContext('webgl2');
        const coordsDiv = document.getElementById('coords');

        // Prevent context menu on right click
        canvas.addEventListener('contextmenu', event => event.preventDefault());

        if (!gl) {
            document.body.innerHTML = "WebGL2 is not supported by your browser.";
        }

        // Resize canvas to full screen
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        window.addEventListener('resize', resize);
        resize();

        // Vertex Shader
        const vsSource = `#version 300 es
        in vec4 position;
        void main() {
            gl_Position = position;
        }`;

        // Fragment Shader
        const fsSource = `#version 300 es
        precision highp float;

        uniform vec2 iResolution;
        uniform float iTime;
        uniform vec4 iMouse;
        uniform vec3 iCameraPos; 
        uniform vec2 iCameraAngle; 

        out vec4 fragColor;

        // --- SCENE CONSTANTS ---
        #define MAX_STEPS 100
        #define MAX_DIST 50.0
        #define SURF_DIST 0.001
        
        // Material IDs
        #define MAT_FLOOR 1.0
        #define MAT_OUTSIDE_OBJ 2.0
        #define MAT_BOX_OUTSIDE 3.0
        #define MAT_BOX_INSIDE 4.0
        #define MAT_SCREEN 5.0

        // Box Settings
        vec3 boxSize = vec3(2.0, 1.5, 2.0);
        float wallThickness = 0.1;
        float pinholeRadius = 0.08;
        // Pinhole offset relative to box center
        vec3 pinholeOffset = vec3(0.0, 0.0, 2.0); 

        // Box Locations
        vec3 posBox1 = vec3(0.0, 0.0, 0.0);  // Center
        vec3 posBox2 = vec3(-6.0, 0.0, 0.0); // Left
        vec3 posBox3 = vec3(6.0, 0.0, 0.0);  // Right

        // --- SDF PRIMITIVES ---
        
        float sdBox(vec3 p, vec3 b) {
            vec3 q = abs(p) - b;
            return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
        }

        float sdSphere(vec3 p, float s) {
            return length(p) - s;
        }

        mat2 rot(float a) {
            float s = sin(a);
            float c = cos(a);
            return mat2(c, -s, s, c);
        }

        // Generate SDF for a single camera box at local coordinate p
        float sdCameraInstance(vec3 p) {
            // Outer shell
            float dBoxOuter = sdBox(p, boxSize);
            // Inner hollow
            float dBoxInner = sdBox(p, boxSize - vec3(wallThickness));
            
            // The Pinhole (Cylinder cutout on Z axis)
            vec3 holeP = p - pinholeOffset;
            float dHole = length(holeP.xy) - pinholeRadius;
            // Constrain hole to front face depth
            float holeDepth = abs(holeP.z) - wallThickness * 2.0; 
            dHole = max(dHole, holeDepth);

            // Combine
            float d = max(dBoxOuter, -dBoxInner);
            d = max(d, -dHole);
            return d;
        }

        // --- SCENE MAPPING ---

        vec2 map(vec3 p) {
            // 1. The Room / Floor
            float dFloor = p.y + 2.0;
            
            // 2. Floating Objects
            vec3 objPos = p - vec3(0.0, 0.0, 6.0); 
            objPos.xz *= rot(iTime);
            objPos.xy *= rot(iTime * 0.5);
            float dObjects = sdBox(objPos, vec3(0.7));
            vec3 spherePos = p - vec3(2.5 * sin(iTime), 0.0, 5.0 + 2.5 * cos(iTime));
            float dSphere = sdSphere(spherePos, 0.5);
            dObjects = min(dObjects, dSphere);

            // 3. The Pinhole Camera Boxes (Multiple Instances)
            float dB1 = sdCameraInstance(p - posBox1);
            float dB2 = sdCameraInstance(p - posBox2);
            float dB3 = sdCameraInstance(p - posBox3);
            
            float dCameraBoxes = min(dB1, min(dB2, dB3));

            // --- IDENTIFY MATERIALS ---
            
            vec2 res = vec2(dFloor, MAT_FLOOR);

            if (dObjects < res.x) res = vec2(dObjects, MAT_OUTSIDE_OBJ);
            
            if (dCameraBoxes < res.x) {
                res.x = dCameraBoxes;
                
                // Determine which box we are inside/touching to set local coordinates
                vec3 localP;
                // Simple nearest neighbor check for the 3 boxes
                float d1 = length(p - posBox1);
                float d2 = length(p - posBox2);
                float d3 = length(p - posBox3);
                
                if (d1 < d2 && d1 < d3) localP = p - posBox1;
                else if (d2 < d3)       localP = p - posBox2;
                else                    localP = p - posBox3;

                // Check logic inside the local box frame
                bool isInsideBounds = sdBox(localP, boxSize - vec3(wallThickness * 0.5)) < 0.0;
                
                if (isInsideBounds) {
                    // Check back wall
                    float distToBackWall = abs(localP.z - (-boxSize.z + wallThickness));
                    if (distToBackWall < 0.2 && abs(localP.x) < boxSize.x - 0.2 && abs(localP.y) < boxSize.y - 0.2) {
                        res.y = MAT_SCREEN;
                    } else {
                        res.y = MAT_BOX_INSIDE;
                    }
                } else {
                    res.y = MAT_BOX_OUTSIDE;
                }
            }

            return res;
        }

        // --- RAYMARCHING ---

        vec2 rayMarch(vec3 ro, vec3 rd) {
            float dO = 0.0;
            float m = 0.0;
            
            for(int i = 0; i < MAX_STEPS; i++) {
                vec3 p = ro + rd * dO;
                vec2 dS = map(p);
                dO += dS.x;
                m = dS.y;
                if(dO > MAX_DIST || abs(dS.x) < SURF_DIST) break;
            }
            return vec2(dO, m);
        }

        vec3 getNormal(vec3 p) {
            float d = map(p).x;
            vec2 e = vec2(0.001, 0.0);
            vec3 n = d - vec3(
                map(p-e.xyy).x,
                map(p-e.yxy).x,
                map(p-e.yyx).x);
            return normalize(n);
        }

        // --- LIGHTING & MATERIALS ---

        vec3 getMaterialColor(vec3 p, float matID, vec3 n, vec3 rd) {
            vec3 col = vec3(0.0);
            vec3 lightPos = vec3(5.0, 10.0, 5.0);
            vec3 l = normalize(lightPos - p);
            float dif = clamp(dot(n, l), 0.0, 1.0);
            float amb = 0.1;

            if (matID == MAT_FLOOR) {
                float check = mod(floor(p.x) + floor(p.z), 2.0);
                col = vec3(0.2 + 0.3 * check);
                col *= (dif + amb);
            } 
            else if (matID == MAT_OUTSIDE_OBJ) {
                col = vec3(1.0, 0.5, 0.2); 
                col += 0.5 * sin(p * 2.0);
                col *= (dif + amb);
            } 
            else if (matID == MAT_BOX_OUTSIDE) {
                col = vec3(0.8, 0.8, 0.8);
                col *= (dif + amb);
            } 
            else if (matID == MAT_BOX_INSIDE) {
                col = vec3(0.05);
            }
            else if (matID == MAT_SCREEN) {
                col = vec3(0.1);
            }

            float d = length(p - vec3(0.0, 0.0, -5.0)); 
            col = mix(col, vec3(0.0), 1.0 - exp(-0.02 * d * d));
            return col;
        }

        void main() {
            vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;
            
            vec3 ro = iCameraPos;
            float yaw = iCameraAngle.x;
            float pitch = iCameraAngle.y;
            
            vec3 forward = normalize(vec3(sin(yaw), pitch, cos(yaw)));
            vec3 right = normalize(cross(vec3(0,1,0), forward));
            vec3 up = cross(forward, right);
            vec3 rd = normalize(forward + right * uv.x + up * uv.y);

            vec2 hit = rayMarch(ro, rd);
            float d = hit.x;
            float mat = hit.y;
            
            vec3 col = vec3(0.0);

            if (d < MAX_DIST) {
                vec3 p = ro + rd * d;
                vec3 n = getNormal(p);
                
                if (mat == MAT_SCREEN) {
                    // Determine which box's pinhole we are using
                    vec3 center = posBox1;
                    float d1 = length(p - posBox1);
                    float d2 = length(p - posBox2);
                    float d3 = length(p - posBox3);
                    
                    if (d2 < d1 && d2 < d3) center = posBox2;
                    if (d3 < d1 && d3 < d2) center = posBox3;
                    
                    vec3 specificPinhole = center + pinholeOffset;
                    vec3 dirToHole = normalize(specificPinhole - p);
                    
                    if (dot(n, dirToHole) > 0.0) {
                        vec3 secondaryRo = specificPinhole + dirToHole * 0.5; 
                        vec3 secondaryRd = dirToHole;
                        vec2 secondaryHit = rayMarch(secondaryRo, secondaryRd);
                        
                        if (secondaryHit.x < MAX_DIST) {
                            vec3 p2 = secondaryRo + secondaryRd * secondaryHit.x;
                            vec3 n2 = getNormal(p2);
                            vec3 projectedColor = getMaterialColor(p2, secondaryHit.y, n2, secondaryRd);
                            
                            col = projectedColor;
                            float angle = dot(vec3(0,0,1), dirToHole); // Assuming boxes align with Z
                            col *= pow(abs(angle), 4.0);
                            col += (fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453) * 0.05);
                        } 
                    } else {
                        col = vec3(0.05);
                    }
                } 
                else {
                    col = getMaterialColor(p, mat, n, rd);
                }
            }

            col = pow(col, vec3(1.0/2.2));
            fragColor = vec4(col, 1.0);
        }`;

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        const vs = createShader(gl, gl.VERTEX_SHADER, vsSource);
        const fs = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
        const program = gl.createProgram();
        gl.attachShader(program, vs);
        gl.attachShader(program, fs);
        gl.linkProgram(program);

        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            -1, -1,  1, -1, -1,  1,
            -1,  1,  1, -1,  1,  1,
        ]), gl.STATIC_DRAW);

        const positionLoc = gl.getAttribLocation(program, 'position');
        gl.enableVertexAttribArray(positionLoc);
        gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);

        gl.useProgram(program);

        const resLoc = gl.getUniformLocation(program, 'iResolution');
        const timeLoc = gl.getUniformLocation(program, 'iTime');
        const mouseLoc = gl.getUniformLocation(program, 'iMouse');
        const camPosLoc = gl.getUniformLocation(program, 'iCameraPos');
        const camAngleLoc = gl.getUniformLocation(program, 'iCameraAngle');

        let camPos = { ...INITIAL_CAM_POS };
        let camYaw = INITIAL_YAW;
        let camPitch = INITIAL_PITCH;

        let isAnimating = false;
        let animStartTime = 0;
        let animStartPos = {x:0, y:0, z:0};
        let animStartYaw = 0;
        let animStartPitch = 0;

        canvas.addEventListener('mousedown', e => {
            if (e.button === 2) {
                isAnimating = true;
                animStartTime = performance.now();
                animStartPos = { ...camPos };
                animStartYaw = camYaw;
                animStartPitch = camPitch;
                return;
            }
        });

        canvas.addEventListener('mousemove', e => {
            if (isAnimating) return;
            if(e.buttons === 1) {
                camYaw += e.movementX * 0.005;
                camPitch -= e.movementY * 0.005;
                camPitch = Math.max(-1.5, Math.min(1.5, camPitch));
            }
        });

        const keys = {};
        window.addEventListener('keydown', (e) => { keys[e.key.toLowerCase()] = true; });
        window.addEventListener('keyup', (e) => { keys[e.key.toLowerCase()] = false; });

        function lerp(start, end, t) {
            return start * (1 - t) + end * t;
        }

        function render(time) {
            const now = performance.now();
            time *= 0.001; 

            if (isAnimating) {
                const t = (now - animStartTime) / 1000.0;
                if (t < 2.0) {
                    const prog = Math.min(t / 2.0, 1.0);
                    const smooth = prog * prog * (3 - 2 * prog);
                    camPos.x = lerp(animStartPos.x, 0.0, smooth);
                    camPos.y = lerp(animStartPos.y, 0.0, smooth);
                    camPos.z = lerp(animStartPos.z, 0.0, smooth);
                    camYaw = lerp(animStartYaw, 0.0, smooth);
                    camPitch = lerp(animStartPitch, 0.0, smooth);
                } else if (t < 3.0) {
                    camYaw = 0.0; camPitch = 0.0; camPos.x = 0; camPos.y = 0; camPos.z = 0;
                } else if (t < 5.0) {
                    const prog = Math.min((t - 3.0) / 2.0, 1.0);
                    const smooth = prog * prog * (3 - 2 * prog);
                    camYaw = lerp(0.0, Math.PI, smooth);
                } else {
                    camYaw = Math.PI;
                }
                coordsDiv.innerText = "ANIMATION ACTIVE\nRight click restart.";
            } 
            else {
                const speed = 0.1;
                const forwardX = Math.sin(camYaw);
                const forwardZ = Math.cos(camYaw);
                const rightX = Math.cos(camYaw); 
                const rightZ = -Math.sin(camYaw);

                if (keys['w']) { camPos.x += forwardX * speed; camPos.z += forwardZ * speed; }
                if (keys['s']) { camPos.x -= forwardX * speed; camPos.z -= forwardZ * speed; }
                if (keys['d']) { camPos.x += rightX * speed; camPos.z += rightZ * speed; }
                if (keys['a']) { camPos.x -= rightX * speed; camPos.z -= rightZ * speed; }
                if (keys['e']) camPos.y += speed;
                if (keys['q']) camPos.y -= speed;

                coordsDiv.innerText = `POS: X:${camPos.x.toFixed(2)} Y:${camPos.y.toFixed(2)} Z:${camPos.z.toFixed(2)}\nROT: Y:${camYaw.toFixed(2)} P:${camPitch.toFixed(2)}`;
            }

            gl.uniform2f(resLoc, canvas.width, canvas.height);
            gl.uniform1f(timeLoc, time);
            gl.uniform4f(mouseLoc, 0, 0, 0, 0);
            gl.uniform3f(camPosLoc, camPos.x, camPos.y, camPos.z);
            gl.uniform2f(camAngleLoc, camYaw, camPitch);

            gl.drawArrays(gl.TRIANGLES, 0, 6);
            requestAnimationFrame(render);
        }
        requestAnimationFrame(render);

    </script>
</body>
</html>
